export const data = {
	title: 'Visuales con música de Spotify',
	tldr: 'Una aplicación hecha en React y NodeJS',
	date: '2020-01-27'
}

La mayoría de aplicaciones que se pueden encontrar en la red utilizan el micrófono de la computadora para crear visuales. Sin embargo, no hay manera de saber mucho sobre la canción que está sonando porque la música está en vivo, y para hacer un análisis más detallado se tendría que saber toda la información de la canción. Spotify cuenta con una [API](https://developer.spotify.com/documentation/web-api/reference/) con información de las canciones en su repertorio. En este post hablaré de cómo crear los principios de la aplicación, los visuales en sí ya corren por su cuenta. Si sólo quieres ver el código puedes ir a mi [Github](https://github.com/dariozubi/spotify-visualizer).

## React

La base de la aplicación está en hecha en [React](https://reactjs.org/) con su aplicación [CRA](https://github.com/facebook/create-react-app). Para empezar necesitas instalar [NodeJS](https://nodejs.org/en/download/) antes. Después en una terminal escribe:

```
npx create-react-app spotify-app
```

Yo le puse `spotify-app` de nombre pero puedes usar el que sea. Una vez que se termine de crear la aplicación verás que hay una nueva carpeta con el nombre que hayas usado. Esa carpeta contiene todos los archivos necesarios para empezar y es la base del proyecto. Todos los comandos que empiecen por `npm` de ahora en adelante tienen que correrse ahí.

Para no tener problemas más adelante, cambia el contenido del archivo `src/index.js` por:

```
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';

ReactDOM.render(<App />, document.getElementById('root'));
```

Básicamente es quitar el `service worker` porque genera un error de seguridad al estar trabajando en el `localhost`.

## API de Spotify

Para poder hacer uso de los datos de Spotify, se necesita primero hacer una aplicación en su [dashboard](https://developer.spotify.com/dashboard/). Sólo sigue las indicaciones que te den en la página y una vez creada la aplicación agrega `http://localhost:8001/callback` a los _Redirect URIs_.

Spotify te identifica con el ID y llave secreta de la aplicación que acabas de crear. Vamos a guardarlas en un archivo con el nombre `.env` en la base de tu aplicación con este formato:

```
client_id = 'YOUR_CLIENT_ID'
client_secret = 'YOUR_CLIENT_SECRET'

# Redirect URI:
redirect_uri = 'http://localhost:8001/callback'

# No cambiar esto!!
scope = 'user-read-playback-state'
access_token = 'DAZUMA_ACCESS_TOKEN'
refresh_token = 'DAZUMA_REFRESH_TOKEN'
```

Estas credenciales nos van a ayudar a conectarnos con Spotify. Dado que no podemos usar esas credenciales en el lado del cliente (en el frot-end), necesitamos hacer ajustes al servidor para que la autorización se lleve a cabo de ese lado. 

## NodeJS

La base de CRA es un servidor en NodeJS. Hay que modificar esta parte para poder conectarse a la API. Para ello vamos a usar varios paquetes que nos ayuden en el back-end. Usamos el flag `--save-dev` para que los módulos que se instalen se hagan únicamente del lado del servidor:

```
npm install body-parser cookie-parser express node-env-run npm-run-all --save-dev
```

En el archivo `package.json` debe aparecer al final la lista de estas nuevas dependencias bajo el nombre `devDependencies`. 

Para seguir el flujo de autorización de la API vamos a cambiar los scripts que se crearon por default con CRA. También vamos a agregar un proxy porque se van a estar corriendo dos aplicaciones al mismo tiempo, la de CRA y el servidor que vamos a crear. Para hacer esto, en el archivo `package.json` eliminamos el objeto `scripts` y lo sustituimos por:

```
"scripts": {
    "react": "set PORT=8000 && react-scripts start",
    "server": "node-env-run server",
    "start": "run-p server react"
  },
"proxy": "http://localhost:8001",
```

Ya que está configurado el servidor tenemos que programar todo el flujo de autorización. Para esto, crea un folder llamado `server` en la base de tu aplicación. Ahí adentro crea un archivo llamado `index.js` con este contenido:

```
const express = require('express');
const bodyParser = require('body-parser');
const querystring = require('querystring');
const cookieParser = require('cookie-parser');
const request = require('request');

const app = express();
app.use(bodyParser.urlencoded({ extended: false }));

app.use((req, res, next) => {
  res.set('Access-Control-Allow-Origin', 'http://localhost:8000');
  res.set('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');
  next();
});

app.use(cookieParser());

app.get('/refresh', (req, res) => {
  const refresh_token = req.query.token;

  if (!refresh_token) {
    res.status(400);
    res.send({ ERROR: 'No token provided.' });
    return
  }

  const authOptions = {
    url: 'https://accounts.spotify.com/api/token',
    headers: { 'Authorization': 'Basic ' + (new Buffer(process.env.client_id + ':' + process.env.client_secret).toString('base64')) },
    form: {
      refresh_token,
      grant_type: 'refresh_token'
    },
    json: true
  };

  request.post(authOptions, (error, response, body) => {
    if (!error && response.statusCode === 200) {
      const access_token = body.access_token
      res.send({ access_token });
    } else {
      res.send({ message: 'The end is near'});
    };
  });
});

app.get('/login', (req, res) => {
  const auth_id = req.query.auth_id
  const query = querystring.stringify({
    response_type: 'code',
    client_id: process.env.client_id,
    scope: process.env.scope,
    redirect_uri: process.env.redirect_uri,
    state: auth_id
  });

  res.cookie(process.env.state_key, auth_id);
  res.redirect('https://accounts.spotify.com/authorize?' + query);
});

app.get('/callback', (req, res) => {
  const code = req.query.code || null;
  
  const authOptions = {
    url: 'https://accounts.spotify.com/api/token',
    form: {
      code: code,
      redirect_uri: process.env.redirect_uri,
      grant_type: 'authorization_code'
    },
    headers: {
      'Authorization': 'Basic ' + (new Buffer(process.env.client_id + ':' + process.env.client_secret).toString('base64'))
    },
    json: true
  };
  
  request.post(authOptions, (error, response, body) => {
    if (!error && res.statusCode === 200) {
      res.cookie(process.env.access_token, body.access_token);
      res.cookie(process.env.refresh_token, body.refresh_token);
      // res.cookie(process.env.refresh_code, code);

      res.redirect('http://localhost:8000/#start');
    } else {
      res.redirect('/#' + querystring.stringify({ error: 'invalid_token' }));
    }
  })
})

app.get('/auth', (req, res) => {
  const auth_id = Math.random().toString(36).slice(5, 11)
  res.set('Content-Type', 'application/json');
  res.send(JSON.stringify({ auth_id: Math.random().toString(36).slice(5, 11) }));
});

app.listen(8001, () =>
  console.log('Express server is running on localhost:8001')
);
```

Los detalles están en el código, pero lo único que hace este código es seguir el protocolo de [autorización](https://developer.spotify.com/documentation/general/guides/authorization-guide/#authorization-code-flow) de Spotify.

## Front-end

Ya con las bases del servidor necesitamos que nuestra aplicación en React se conecte con todo lo que está pasando detrás. Para esto vamos a crear un componente vacío (renderless) que se haga cargo de la conexión con Spotify. Crea el folder `/src/components` y adentro crea un archivo llamado `APIHandler.js` con este contenido:

```
import { Component } from 'react';
import * as cookie from './cookie';

 export default class ApiHandler extends Component{

  constructor(props){
  	super(props);

  	this.state = {
      track: {},
      track_analysis: {},
      track_progress: 0,
  	  headers: {},
      refresh_token: '',
      last_update: 0,
      section: -1,
      tatum: -1
  	}

  	this.setActive = this.setActive.bind(this);
    this.setTrack = this.setTrack.bind(this);
  }

  componentDidMount() {

    if (window.location.hash === '#start') {

      this.setState({
        refresh_token: cookie.get('DAZUMA_REFRESH_TOKEN'),
        headers: new Headers({
          'Authorization': 'Bearer ' + cookie.get('DAZUMA_ACCESS_TOKEN'),
          'Accept': 'application/json'
        })
      });

      this.ping();

      this.timerId = setInterval(this.updateProgress.bind(this), 50);

    } else {

      this.auth();
    }
    
  };

  componentWillUnmount(){
    clearInterval(this.timerId);
    clearTimeout(this.callId);
  }

  auth () {
    fetch('http://localhost:8001/auth')
      .then(res => res.json())
      .then(res => res.auth_id ? window.location.href = 'http://localhost:8001/login?auth_id=' + res.auth_id : null) 
      .catch(err => console.log(err))
  }

  updateProgress(){

    if (this.props.active){

      this.setState((state,props)=>({ 
        track_progress: state.track_progress + window.performance.now() - state.last_update,
        last_update: window.performance.now() 
      }));
      
      let tempo = 0;
      let key = 0;
      let mode = 0;
      let loudness = 0;
      let section = 0;
      let tatum = 0;
      let beat = 0;
      let bar = 0;
      let segment = 0;

      for (let i=0; i<this.state.track_analysis.sections.length; i++){

        if (this.state.track_progress > this.state.track_analysis.sections[i].start){
          section = this.state.track_analysis.sections[i].start;
          tempo = this.state.track_analysis.sections[i].tempo/60*1000/this.state.track_analysis.sections[i].time_signature;
          key = this.state.track_analysis.sections[i].key;
          mode = this.state.track_analysis.sections[i].mode;
          loudness = this.state.track_analysis.sections[i].loudness;
        }

        else break;
      }

      for (let i=0; i<this.state.track_analysis.tatums.length; i++){
        if (this.state.track_progress > this.state.track_analysis.tatums[i].start)
          tatum = this.state.track_analysis.tatums[i].start;
        else break;
      }

      for (let i=0; i<this.state.track_analysis.beats.length; i++){
        if (this.state.track_progress > this.state.track_analysis.beats[i].start)
          beat = this.state.track_analysis.beats[i].start;
        else break;
      }

      for (let i=0; i<this.state.track_analysis.bars.length; i++){
        if (this.state.track_progress > this.state.track_analysis.bars[i].start)
          bar = this.state.track_analysis.bars[i].start;
        else break;
      }

      for (let i=0; i<this.state.track_analysis.segments.length; i++){
        if (this.state.track_progress > this.state.track_analysis.segments[i].start)
          segment = this.state.track_analysis.segments[i].start;
        else break;
      }

      this.setTrack({
        name: this.state.track.name,
        tempo: tempo,
        key: key,
        mode: mode,
        loudness: loudness,
        tempo_pulse: this.state.track_progress % tempo < 100,
        section_pulse: Math.abs(this.state.track_progress - section) < 500,
        tatum_pulse: Math.abs(this.state.track_progress - tatum) < 100,
        beat_pulse: Math.abs(this.state.track_progress - beat) < 100,
        bar_pulse: Math.abs(this.state.track_progress - bar) < 100,
        segment_pulse: Math.abs(this.state.track_progress - segment) < 100
      });

      this.setState({
        section: section,
        tatum: tatum
      });
    }
  }

  ping(){
    this.callId = setTimeout(() => this.getAPIInfo(), 3000);
  }

  getAPIInfo() {

    const now = window.performance.now();

    const request = new Request('https://api.spotify.com/v1/me/player', {headers: this.state.headers});

    fetch(request)
      .then(res =>{

        if (res.statusText === "No Content")
          return res; 

        return res.json();

      })
      .then(res => {

        if (res.statusText === "No Content"){
          this.setActive(false);
          this.setState({ track: "NO TRACK" });
          return "";
        }

        if (res.error && res.error.status === 401)
          return this.getNewToken(); 

        const track = res.item;
        const playing = res.is_playing;
        const progress = res.progress_ms + (window.performance.now() - now);

        const song_in_sync = JSON.stringify(this.state.track) === JSON.stringify(track)

        const error = this.state.track_progress - progress;

        if (playing && !this.props.active) {

          if (song_in_sync) {

            this.setActive(true);

            this.setState({ 
              track_progress: progress,
              last_update: window.performance.now() 
            });
          }

          else

            this.getTrackData({ track, progress })
        }

        if (!playing && this.props.active) {

          this.setActive(false);

        }

        if (playing && this.props.active && !song_in_sync) {

          this.getTrackData({ track, progress })

        }

        if (playing && this.props.active && song_in_sync && Math.abs(error) > 50) {

          this.setState({ 
            track_progress: progress,
            last_update: window.performance.now() 
          });

        } 

      })
      .then(this.ping())
      .catch(err => console.log(err))
  }

  getTrackData ({ track, progress }) {

    const now = window.performance.now();

    fetch(new Request('https://api.spotify.com/v1/audio-analysis/' + track.id, {headers: this.state.headers}))
      .then(res => res.json())
      .then(res =>{

        if (res.error && res.error.status === 401) {
          return this.getNewToken(); 
        }

        const rhythms = ['bars', 'beats', 'sections', 'segments', 'tatums'];

        let analysis = res;

        for (let rhythm of rhythms){
          let item = analysis[rhythm];
          for (let i=0; i<item.length; i++){
            analysis[rhythm][i].start *= 1000;
            analysis[rhythm][i].duration *= 1000;
          }
        }

        analysis.track.end_of_fade_in *= 1000;
        analysis.track.start_of_fade_out *= 1000;
        analysis.track.duration *= 1000;

        this.setActive(true);

        this.setState({ 
          track: track,
          track_analysis: analysis,
          track_progress: progress + (window.performance.now() - now),
          last_update: window.performance.now() 
        });

    })
    .catch(err => console.log(err))
  }

  getNewToken () {

    console.warn("Fetching new token");

    if (!this.state.refresh_token) {
      return window.location.href = ''
    }

    fetch('http://localhost:8001/refresh?token=' + this.state.refresh_token)
      .then(res => res.json())
      .then(res => {
        this.setState({
          headers: new Headers({
            'Authorization': 'Bearer ' + res.access_token,
            'Accept': 'application/json'
          })
        });
      })
      .catch(err => console.log(err));
  }

  setActive(active){
    this.props.setActive(active);
  }

  setTrack(track){
    this.props.setTrack(track);
  }

  render() {
    return null;
  }

}
```

Este componente se va a encargar de mantener actualizada toda la información del track que estemos escuchando en Spotify. Es aquí donde va a estar la diferencia con respecto a un sistema que sólo escucha lo que está sonando en el micrófono.

> Al estar conectado directamente con Spotify, puedes escuchar la música en unas bocinas, ver los visuales en una computadora y controlar las canciones que escuchas en un teléfono y todo va a estar sincronizado con el servidor.

El método `getTrackData` es el que obtiene la información de cada track. En este caso sólo se está usando la información del ritmo (_bars, beats, sections, segments_ y _tatums_), pero hay más información que se puede utilizar tanto en el [análisis](https://developer.spotify.com/documentation/web-api/reference/tracks/get-audio-analysis/) como en las [características](https://developer.spotify.com/documentation/web-api/reference/tracks/get-audio-features/) de la canción. 

Este componente lee una cookie para mantener al usuario conectado con la aplicación. Para ello hay que crear un archivo llamado `cookie.js` en la misma carpeta con lo siguiente:

```
export function get (sKey) {
  if (!sKey) { return null; }
  return decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" 
    + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") 
    + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null;
}

export function set (sKey, sValue, vEnd, sPath, sDomain, bSecure) {
  if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) { return false; }
  var sExpires = "";
  if (vEnd) {
    switch (vEnd.constructor) {
      case Number:
        sExpires = vEnd === Infinity ? "; expires=Fri, 31 Dec 9999 23:59:59 GMT" : "; max-age=" + vEnd;
        break;
      case String:
        sExpires = "; expires=" + vEnd;
        break;
      case Date:
        sExpires = "; expires=" + vEnd.toUTCString();
        break;
    }
  }
  document.cookie = encodeURIComponent(sKey) + "=" 
    + encodeURIComponent(sValue) + sExpires + (sDomain ? "; domain=" + sDomain : "") 
    + (sPath ? "; path=" + sPath : "") + (bSecure ? "; secure" : "");
  return true;
}

export function remove (sKey, sPath, sDomain) {
  if (!this.hasItem(sKey)) { return false; }
  document.cookie = encodeURIComponent(sKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT" 
    + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "");
  return true;
}

export function has (sKey) {
  if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) { return false; }
  return (new RegExp("(?:^|;\\s*)" 
    + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") 
    + "\\s*\\=")).test(document.cookie);
}

export function keys () { 
  var aKeys = document.cookie.replace(/((?:^|\s*;)[^\=]+)(?=;|$)|^\s*|\s*(?:\=[^;]*)?(?:\1|$)/g, "").split(/\s*(?:\=[^;]*)?;\s*/);
  for (var nLen = aKeys.length, nIdx = 0; nIdx < nLen; nIdx++) { aKeys[nIdx] = decodeURIComponent(aKeys[nIdx]); }
  return aKeys;
}
```

## Visuales

Para generar los visuales vamos a ocupar una de las librerías más usadas para hacer aplicaciones web en 3D, [ThreeJS](https://threejs.org/). Como nuestra aplicación está hecha en React necesitamos también de una librería que conecte Three con React. Esa librería es [react-three-fiber](https://github.com/react-spring/react-three-fiber). Para este ejemplo vamos a usar también `react-spring` para facilitar las animaciones.

Como todas estas librerías se van a correr en el front-end, para instalarlas sólo necesitamos usar:

```
npm install three react-three-fiber react-spring
```

Ya teniendo todas las librerías hay que crear una escena que utilice la información de Spotify para ser audioreactiva. En este caso aquí hay una escena muy sencilla que sirve para visualizar los diferentes tipos de ritmos que se obtienen de una canción. Sólo copia y pega este código en un archivo que se llame `Scene.js` en `src/components`.

```
import React from 'react';
import { Canvas, useThree, useFrame } from "react-three-fiber"
import { useSpring, a } from "react-spring/three"

function Tempo(props) {
  const { size, viewport } = useThree()
  const aspect = size.width / viewport.width
  const [spring, set] = useSpring(() => ({
    scale: [0.5, 0.5, 0.5],
    position: props.position,
    rotation: [0, 0, 0],
    config: { mass: 5, friction: 50, tension: 100 }
  }))

  useFrame(() => set({ scale: props.track.tempo_pulse ? [0.9, 0.9, 0.9] : [0.7, 0.7, 0.7] }));

  return (
    <a.mesh {...spring} castShadow>
      <dodecahedronBufferGeometry attach="geometry" args={[1.4, 0]} />
      <meshNormalMaterial attach="material" />
    </a.mesh>
  )
}

function Section(props) {

  const [spring, set] = useSpring(() => ({
    scale: [0.5, 0.5, 0.5],
    position: props.position,
    rotation: [0, 0, 0],
    config: { mass: 5, friction: 50, tension: 100 }
  }));

  useFrame(() => set({ scale: props.track.section_pulse ? [0.7, 0.7, 0.7] : [0.5, 0.5, 0.5] }));

  return (
    <a.mesh {...spring} castShadow>
      <dodecahedronBufferGeometry attach="geometry" args={[1.4, 0]} />
      <meshNormalMaterial attach="material" />
    </a.mesh>
  )
}


function Tatum(props) {

  const [spring, set] = useSpring(() => ({
    scale: [0.5, 0.5, 0.5],
    position: props.position,
    rotation: [0, 0, 0],
    config: { mass: 5, friction: 50, tension: 100 }
  }));

  useFrame(() => set({ scale: props.track.tatum_pulse ? [0.7, 0.7, 0.7] : [0.5, 0.5, 0.5] }));

  return (
    <a.mesh {...spring} castShadow>
      <dodecahedronBufferGeometry attach="geometry" args={[1.4, 0]} />
      <meshNormalMaterial attach="material" />
    </a.mesh>
  )
}

function Beat(props) {

  const [spring, set] = useSpring(() => ({
    scale: [0.5, 0.5, 0.5],
    position: props.position,
    rotation: [0, 0, 0],
    config: { mass: 5, friction: 50, tension: 100 }
  }));

  useFrame(() => set({ scale: props.track.beat_pulse ? [0.7, 0.7, 0.7] : [0.5, 0.5, 0.5] }));

  return (
    <a.mesh {...spring} castShadow>
      <dodecahedronBufferGeometry attach="geometry" args={[1.4, 0]} />
      <meshNormalMaterial attach="material" />
    </a.mesh>
  )
}


function Segment(props) {

  const [spring, set] = useSpring(() => ({
    scale: [0.5, 0.5, 0.5],
    position: props.position,
    rotation: [0, 0, 0],
    config: { mass: 5, friction: 50, tension: 100 }
  }));

  useFrame(() => set({ scale: props.track.segment_pulse ? [0.7, 0.7, 0.7] : [0.5, 0.5, 0.5] }));

  return (
    <a.mesh {...spring} castShadow>
      <dodecahedronBufferGeometry attach="geometry" args={[1.4, 0]} />
      <meshNormalMaterial attach="material" />
    </a.mesh>
  )
}

function Bar(props) {

  const [spring, set] = useSpring(() => ({
    scale: [0.5, 0.5, 0.5],
    position: props.position,
    rotation: [0, 0, 0],
    config: { mass: 5, friction: 50, tension: 100 }
  }));

  useFrame(() => set({ scale: props.track.bar_pulse ? [0.7, 0.7, 0.7] : [0.5, 0.5, 0.5] }));

  return (
    <a.mesh {...spring} castShadow>
      <dodecahedronBufferGeometry attach="geometry" args={[1.4, 0]} />
      <meshNormalMaterial attach="material" />
    </a.mesh>
  )
}

export default function DodecahedronScene(props) {

  const track = props.track;
  const active = props.active;


  return (
    <Canvas 
      style={{ background: "lightblue" }} 
      shadowMap 
      camera={{ position: [0, 0, 5] }}>

        <ambientLight intensity={0.5} />

        <spotLight
          intensity={0.6}
          position={[20, 10, 10]}
          angle={0.2}
          penumbra={1}
          shadow-mapSize-width={2048}
          shadow-mapSize-height={2048}
          castShadow />
          
        <mesh receiveShadow>
          <planeBufferGeometry attach="geometry" args={[1000, 1000]} />
          <meshPhongMaterial attach="material" color="#272727" />
        </mesh>

        <Tempo
          position={[0, 0, 0]}
          track={track} />

        <Section
          position={[2.5, 0, 0]}
          track={track} />

        <Tatum
          position={[-2.5, 0, 0]}
          track={track} />

        <Beat
          position={[0, 2.5, 0]}
          track={track} />

        <Segment
          position={[1.5, -2.5, 0]}
          track={track} />

        <Bar
          position={[-1.5, -2.5, 0]}
          track={track} />
    </Canvas>
  )
}
```

## Script principal

Ya tenemos el backend que nos da la información de la canción que escuchamos y el frontend que muestra esta información con visuales. Lo único que queda es unirlos.

El script principal va a manejar el estado de la aplicación. En este caso sólo va a estar definido por dos valores: `active` y `track`. El primero define si hay alguna canción sonando en ese momento y el segundo tiene toda la información de la canción que esté sonando.

El componente que nos va a dar la información de Spotify necesita de dos callbacks dentro de sus propiedades, `setActive` y `setTrack`. Estos callbacks son parte de las propiedades porque cambian el estado del script principal.

El componente que crea los visuales necesita saber el estado de la canción para mostrar lo que se está escuchando así que tanto `active` como `track` deben ser parte de sus propiedades.

Al final `App.js` en `src` debe de quedar así:

```
import React, { Component } from 'react';
import APIHandler from './components/APIHandler';
import Scene from './components/Scene';
import './App.css';

default class App extends Component{

  constructor(props){
    super(props);

    this.setActive = this.setActive.bind(this);
    this.setTrack = this.setTrack.bind(this);

    this.state = {
      active: false,
      track: {}
    };
  }

  setActive(active){
    this.setState({ active: active });
  }

  setTrack(track){
    this.setState({ track: track })
  }

  render() {

    const track = this.state.track;
    const active = this.state.active;

    return(
      <div className="main">

        <Scene
          active={active}
          track={track} />

        <ApiHandler
          active={active}
          setActive={this.setActive}
          setTrack={this.setTrack} />
      </div>
    );
  }
}
```

Por último, necesitamos hacer unos pequeños ajustes en el css para que la aplicación se vea bien. Para ello hay que cambiar `App.css` a:

```
* {
  box-sizing: border-box;
}

html,
body,
#root {
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  overflow: hidden;
}

#root {
  overflow: auto;
}

body {
  position: fixed;
  overflow: hidden;
  overscroll-behavior-y: none;
  font-family: -apple-system, BlinkMacSystemFont, avenir next, avenir, helvetica neue, helvetica, ubuntu, roboto, noto, segoe ui, arial, sans-serif;
  color: white;
  -webkit-font-smoothing: antialiased;
}

.main {
  position: relative;
  width: 100%;
  height: 100%;
  color: #fff8de;
  overflow: hidden;
}

canvas {
  width: 100%;
  height: 100%;
  position: absolute;
  top: 0;
  overflow: hidden;
}
```

Si todo funciona como debería puedes correr `npm run start` en tu terminal, ir a `http://localhost:8000`, conectarte a tu cuenta de Spotify y ver a unos dodecahedros moverse.