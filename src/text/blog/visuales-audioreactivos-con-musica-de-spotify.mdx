export const data = {
	title: 'Visuales audioreactivos con música de Spotify',
	tldr: 'Una aplicación hecha en React y NodeJS',
	date: '2020-01-28'
}

Existen muchas formas de generar visuales audio-reactivos. La solución más común es usar un micrófono. Esto puede ser suficiente en la mayoría de los casos pero, te limitas al número de parámetros con los que puedes jugar. Si tienes el análisis de la canción de antemano puedes generar cosas mucho más complejas. Puedes generar una narrativa única para cada canción aún cuando los visuales están siendo generados en el momento.

En internet sólo encontré un proyecto que hace esto: [kaleidosync](https://www.kaleidosync.com/). Hay cosas hechas con música propia o algún número limitado de canciones, pero para estar en la época del streaming creo que nos quedamos cortos.

La buena noticia es que lo más complicado ya está hecho. La [API de Spotify](https://developer.spotify.com/documentation/web-api/reference/) cuenta con en un análisis básico de las canciones en su repertorio. No me consta que tenga análisis de todas sus canciones, pero sí de muchas. Lo único que queda hacer es usarla para hacer algo chingón. 

Este proyecto nació como una modificación a kaleidosync, sin embargo evolucionó lo suficiente como para ser un ejercicio con **[React](https://reactjs.org/)** y **[ThreeJS](https://threejs.org/)** de frontend y **[NodeJS](https://nodejs.org/en/download/)** en el backend. Como aprendí varias cosas en el camino, las comparto. 

**_Si no sabes que es React, ThreeJS o NodeJS te recomiendo que primero leas al respecto porque en el texto asumo que sabes al menos las bases de cada uno._**

Si ya te la sabes o sólo quieres ver el código puedes ir a [mi Github](https://github.com/dariozubi/spotify-visualizer) y ahí encontrarás el proyecto completo.

## React

La base de la aplicación está hecha con [create-react-app (CRA)](https://github.com/facebook/create-react-app). Como lo indican en su página, solo basta correr en una terminal el siguiente comando y tener instalado NodeJS para empezar:

`
npx create-react-app spotify-visualizer
`

Yo le puse `spotify-visualizer` de nombre pero puedes usar el que sea. La carpeta con este nombre contiene todos los archivos básicos para el proyecto. 

Todos los comandos que empiecen por `npm` de ahora en adelante tienen que correrse desde adentro de esa carpeta.

Por default, CRA crea un _service worker_ para tu aplicación. Como no lo vamos a usar puedes borrarlo. Para hacerlo sólo cambia el contenido del archivo `src/index.js` por:

```
src/index.js
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';

ReactDOM.render(<App />, document.getElementById('root'));
```

## API de Spotify

Para poder hacer uso de los datos de Spotify, se necesita primero hacer una aplicación en su [Dashboard](https://developer.spotify.com/dashboard/). Sólo sigue las indicaciones que te den en la página y una vez creada la aplicación agrega `http://localhost:8001/callback` a los _Redirect URIs_.

Spotify genera un ID y llave secreta de la aplicación que acabas de crear. Vamos a guardarlas en un archivo con el nombre `.env` en la base de tu aplicación. El nombre del archivo (`.env`, de _environment_) es importante porque más adelante un paquete va a usarlo.

```
.env
client_id = 'YOUR_CLIENT_ID'
client_secret = 'YOUR_CLIENT_SECRET'

# Redirect URI:
redirect_uri = 'http://localhost:8001/callback'

# No cambiar esto!!
scope = 'user-read-playback-state'
access_token = 'DAZUMA_ACCESS_TOKEN'
refresh_token = 'DAZUMA_REFRESH_TOKEN'
```

Estas credenciales nos van a ayudar a conectarnos con Spotify. No podemos usar estas credenciales en el lado del cliente por seguridad. Por lo tanto, necesitamos hacer cambios al servidor para que la autorización se lleve a cabo.

## NodeJS

La base de CRA es un servidor en NodeJS. Como ya mencioné, hay que modificar el servidor para poder conectarse a la API. Para ello vamos a usar varios paquetes que nos ayuden a simplificar el proceso.

Para la instalación usamos el flag `--save-dev` para que los módulos que se instalen se hagan únicamente del lado del servidor y no en el frontend:

`
npm install body-parser cookie-parser express node-env-run npm-run-all --save-dev
`

En el archivo `package.json` deben aparecer al final estas nuevas dependencias bajo el nombre `devDependencies`. 

Para seguir el [flujo de autorización](https://developer.spotify.com/documentation/general/guides/authorization-guide/#authorization-code-flow) de la API vamos a cambiar los scripts que se crearon por defecto con CRA. También vamos a agregar un proxy porque se van a estar corriendo dos aplicaciones al mismo tiempo, la de CRA y el servidor que vamos a crear. Para hacer esto, en el archivo `package.json` eliminamos el objeto `scripts` y lo sustituimos por:

```
package.json
"scripts": {
    "react": "set PORT=8000 && react-scripts start",
    "server": "node-env-run server",
    "start": "run-p server react"
  },
"proxy": "http://localhost:8001",
```
En el `script` _start_ estamos usando el comando `run-p` del paquete `npm-run-all` para correr simultáneamente el servidor de react y el nuestro (_server_). Nuestro servidor usa el archivo `.env` (creado en la sección anterior) usando el paquete `node-env-run`.

Ya que está configurado el servidor tenemos que programar todo el flujo de autorización de la API de Sportify. Para esto, crea una carpeta llamada `server` en la base de tu aplicación. Ahí adentro crea un archivo llamado `index.js` con este contenido:

```
index.js
const express = require('express');
const bodyParser = require('body-parser');
const querystring = require('querystring');
const cookieParser = require('cookie-parser');
const request = require('request');

const app = express();
app.use(bodyParser.urlencoded({ extended: false }));

app.use((req, res, next) => {
  res.set('Access-Control-Allow-Origin', 'http://localhost:8000');
  res.set('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');
  next();
});

app.use(cookieParser());

app.get('/refresh', (req, res) => {
  const refresh_token = req.query.token;

  if (!refresh_token) {
    res.status(400);
    res.send({ ERROR: 'No token provided.' });
    return
  }

  const authOptions = {
    url: 'https://accounts.spotify.com/api/token',
    headers: { 'Authorization': 'Basic ' + (new Buffer(process.env.client_id + ':' + process.env.client_secret).toString('base64')) },
    form: {
      refresh_token,
      grant_type: 'refresh_token'
    },
    json: true
  };

  request.post(authOptions, (error, response, body) => {
    if (!error && response.statusCode === 200) {
      const access_token = body.access_token
      res.send({ access_token });
    } else {
      res.send({ message: 'The end is near'});
    };
  });
});

app.get('/login', (req, res) => {
  const auth_id = req.query.auth_id
  const query = querystring.stringify({
    response_type: 'code',
    client_id: process.env.client_id,
    scope: process.env.scope,
    redirect_uri: process.env.redirect_uri,
    state: auth_id
  });

  res.cookie(process.env.state_key, auth_id);
  res.redirect('https://accounts.spotify.com/authorize?' + query);
});

app.get('/callback', (req, res) => {
  const code = req.query.code || null;
  
  const authOptions = {
    url: 'https://accounts.spotify.com/api/token',
    form: {
      code: code,
      redirect_uri: process.env.redirect_uri,
      grant_type: 'authorization_code'
    },
    headers: {
      'Authorization': 'Basic ' + (new Buffer(process.env.client_id + ':' + process.env.client_secret).toString('base64'))
    },
    json: true
  };
  
  request.post(authOptions, (error, response, body) => {
    if (!error && res.statusCode === 200) {
      res.cookie(process.env.access_token, body.access_token);
      res.cookie(process.env.refresh_token, body.refresh_token);
      // res.cookie(process.env.refresh_code, code);

      res.redirect('http://localhost:8000/#start');
    } else {
      res.redirect('/#' + querystring.stringify({ error: 'invalid_token' }));
    }
  })
})

app.get('/auth', (req, res) => {
  const auth_id = Math.random().toString(36).slice(5, 11)
  res.set('Content-Type', 'application/json');
  res.send(JSON.stringify({ auth_id: Math.random().toString(36).slice(5, 11) }));
});

app.listen(8001, () =>
  console.log('Express server is running on localhost:8001')
);
```

Los detalles están en el código, pero lo importante es entender el proceso:
- Empezamos en `http://localhost:8001/login`. Aquí el usuario se va a autenticar con Spotify usando sus credenciales. 
- Una vez que el usuario autoriza la aplicación, Spotify nos regresa unos tokens de pedido que nos permiten solicitar los tokens de autorización (para que el usuario no vuelva a conectarse cada que regresa a la página). Por la configuración que hicimos en el dashboard, Spotify nos regresa a `http://localhost:8001/callback`.
- De ahí enviamos los tokens de pedido para recibir los tokens de autorización y los guardamos en _cookies_.
- Ya que tenemos los tokens, regresamos a `http://localhost:8000/#start` para comenzar la aplicación.

## Front-end

Ya con las bases del servidor necesitamos que nuestra aplicación en React se conecte con todo lo que está pasando detrás. Para esto vamos a crear un componente vacío (renderless) que se haga cargo de la conexión con Spotify. Crea la carpeta `/src/components` y adentro crea un archivo llamado `APIHandler.js` con este contenido:

```
APIHandler.js
import { Component } from 'react';
import * as cookie from './cookie';

 export default class ApiHandler extends Component{

  constructor(props){
  	super(props);

  	this.state = {
      track: {},
      track_analysis: {},
      track_progress: 0,
  	  headers: {},
      refresh_token: '',
      last_update: 0,
      section: -1,
      tatum: -1
  	}

  	this.setActive = this.setActive.bind(this);
    this.setTrack = this.setTrack.bind(this);
  }

  componentDidMount() {

    if (window.location.hash === '#start') {

      this.setState({
        refresh_token: cookie.get('DAZUMA_REFRESH_TOKEN'),
        headers: new Headers({
          'Authorization': 'Bearer ' + cookie.get('DAZUMA_ACCESS_TOKEN'),
          'Accept': 'application/json'
        })
      });

      this.ping();

      this.timerId = setInterval(this.updateProgress.bind(this), 50);

    } else {

      this.auth();
    }
    
  };

  componentWillUnmount(){
    clearInterval(this.timerId);
    clearTimeout(this.callId);
  }

  auth () {
    fetch('http://localhost:8001/auth')
      .then(res => res.json())
      .then(res => res.auth_id ? window.location.href = 'http://localhost:8001/login?auth_id=' + res.auth_id : null) 
      .catch(err => console.log(err))
  }

  updateProgress(){

    if (this.props.active){

      this.setState((state,props)=>({ 
        track_progress: state.track_progress + window.performance.now() - state.last_update,
        last_update: window.performance.now() 
      }));
      
      let tempo = 0;
      let key = 0;
      let mode = 0;
      let loudness = 0;
      let section = 0;
      let tatum = 0;
      let beat = 0;
      let bar = 0;
      let segment = 0;

      for (let i=0; i<this.state.track_analysis.sections.length; i++){

        if (this.state.track_progress > this.state.track_analysis.sections[i].start){
          section = this.state.track_analysis.sections[i].start;
          tempo = this.state.track_analysis.sections[i].tempo/60*1000/this.state.track_analysis.sections[i].time_signature;
          key = this.state.track_analysis.sections[i].key;
          mode = this.state.track_analysis.sections[i].mode;
          loudness = this.state.track_analysis.sections[i].loudness;
        }

        else break;
      }

      for (let i=0; i<this.state.track_analysis.tatums.length; i++){
        if (this.state.track_progress > this.state.track_analysis.tatums[i].start)
          tatum = this.state.track_analysis.tatums[i].start;
        else break;
      }

      for (let i=0; i<this.state.track_analysis.beats.length; i++){
        if (this.state.track_progress > this.state.track_analysis.beats[i].start)
          beat = this.state.track_analysis.beats[i].start;
        else break;
      }

      for (let i=0; i<this.state.track_analysis.bars.length; i++){
        if (this.state.track_progress > this.state.track_analysis.bars[i].start)
          bar = this.state.track_analysis.bars[i].start;
        else break;
      }

      for (let i=0; i<this.state.track_analysis.segments.length; i++){
        if (this.state.track_progress > this.state.track_analysis.segments[i].start)
          segment = this.state.track_analysis.segments[i].start;
        else break;
      }

      this.setTrack({
        name: this.state.track.name,
        tempo: tempo,
        key: key,
        mode: mode,
        loudness: loudness,
        tempo_pulse: this.state.track_progress % tempo < 100,
        section_pulse: Math.abs(this.state.track_progress - section) < 500,
        tatum_pulse: Math.abs(this.state.track_progress - tatum) < 100,
        beat_pulse: Math.abs(this.state.track_progress - beat) < 100,
        bar_pulse: Math.abs(this.state.track_progress - bar) < 100,
        segment_pulse: Math.abs(this.state.track_progress - segment) < 100
      });

      this.setState({
        section: section,
        tatum: tatum
      });
    }
  }

  ping(){
    this.callId = setTimeout(() => this.getAPIInfo(), 3000);
  }

  getAPIInfo() {

    const now = window.performance.now();

    const request = new Request('https://api.spotify.com/v1/me/player', {headers: this.state.headers});

    fetch(request)
      .then(res =>{

        if (res.statusText === "No Content")
          return res; 

        return res.json();

      })
      .then(res => {

        if (res.statusText === "No Content"){
          this.setActive(false);
          this.setState({ track: "NO TRACK" });
          return "";
        }

        if (res.error && res.error.status === 401)
          return this.getNewToken(); 

        const track = res.item;
        const playing = res.is_playing;
        const progress = res.progress_ms + (window.performance.now() - now);

        const song_in_sync = JSON.stringify(this.state.track) === JSON.stringify(track)

        const error = this.state.track_progress - progress;

        if (playing && !this.props.active) {

          if (song_in_sync) {

            this.setActive(true);

            this.setState({ 
              track_progress: progress,
              last_update: window.performance.now() 
            });
          }

          else

            this.getTrackData({ track, progress })
        }

        if (!playing && this.props.active) {

          this.setActive(false);

        }

        if (playing && this.props.active && !song_in_sync) {

          this.getTrackData({ track, progress })

        }

        if (playing && this.props.active && song_in_sync && Math.abs(error) > 50) {

          this.setState({ 
            track_progress: progress,
            last_update: window.performance.now() 
          });

        } 

      })
      .then(this.ping())
      .catch(err => console.log(err))
  }

  getTrackData ({ track, progress }) {

    const now = window.performance.now();

    fetch(new Request('https://api.spotify.com/v1/audio-analysis/' + track.id, {headers: this.state.headers}))
      .then(res => res.json())
      .then(res =>{

        if (res.error && res.error.status === 401) {
          return this.getNewToken(); 
        }

        const rhythms = ['bars', 'beats', 'sections', 'segments', 'tatums'];

        let analysis = res;

        for (let rhythm of rhythms){
          let item = analysis[rhythm];
          for (let i=0; i<item.length; i++){
            analysis[rhythm][i].start *= 1000;
            analysis[rhythm][i].duration *= 1000;
          }
        }

        analysis.track.end_of_fade_in *= 1000;
        analysis.track.start_of_fade_out *= 1000;
        analysis.track.duration *= 1000;

        this.setActive(true);

        this.setState({ 
          track: track,
          track_analysis: analysis,
          track_progress: progress + (window.performance.now() - now),
          last_update: window.performance.now() 
        });

    })
    .catch(err => console.log(err))
  }

  getNewToken () {

    console.warn("Fetching new token");

    if (!this.state.refresh_token) {
      return window.location.href = ''
    }

    fetch('http://localhost:8001/refresh?token=' + this.state.refresh_token)
      .then(res => res.json())
      .then(res => {
        this.setState({
          headers: new Headers({
            'Authorization': 'Bearer ' + res.access_token,
            'Accept': 'application/json'
          })
        });
      })
      .catch(err => console.log(err));
  }

  setActive(active){
    this.props.setActive(active);
  }

  setTrack(track){
    this.props.setTrack(track);
  }

  render() {
    return null;
  }

}
```

Al principio checamos que ya tengamos las _cookies_ con los tokens de autorización del usuario. Si no es así, redirigimos al usario a `http://localhost:8001/login` para que se identifique y hacemos todo el proceso de verificación. Además de ese proceso, este componente se va a encargar de mantener actualizada toda la información del track que estemos escuchando en Spotify en el método `getTrackData`. Es aquí donde va a estar la diferencia con respecto a un sistema que sólo escucha lo que está sonando en el micrófono.

> **Al estar conectado directamente con Spotify, puedes escuchar la música en unas bocinas, ver los visuales en una computadora y controlar las canciones que escuchas en un teléfono y todo va a estar sincronizado con el servidor.**

En este caso sólo se está usando la información del ritmo (_bars, beats, sections, segments_ y _tatums_), pero hay más información que se puede utilizar tanto en el [análisis](https://developer.spotify.com/documentation/web-api/reference/tracks/get-audio-analysis/) como en las [características](https://developer.spotify.com/documentation/web-api/reference/tracks/get-audio-features/) de la canción. 

Dado que estamos usando _cookies_ para los tokens, necesitamos código que las lea. Crea un archivo llamado `cookie.js` en la misma carpeta `/src/components` con lo siguiente:

```
cookie.js
export function get (sKey) {
  if (!sKey) { return null; }
  return decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" 
    + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") 
    + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null;
}

export function set (sKey, sValue, vEnd, sPath, sDomain, bSecure) {
  if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) { return false; }
  var sExpires = "";
  if (vEnd) {
    switch (vEnd.constructor) {
      case Number:
        sExpires = vEnd === Infinity ? "; expires=Fri, 31 Dec 9999 23:59:59 GMT" : "; max-age=" + vEnd;
        break;
      case String:
        sExpires = "; expires=" + vEnd;
        break;
      case Date:
        sExpires = "; expires=" + vEnd.toUTCString();
        break;
    }
  }
  document.cookie = encodeURIComponent(sKey) + "=" 
    + encodeURIComponent(sValue) + sExpires + (sDomain ? "; domain=" + sDomain : "") 
    + (sPath ? "; path=" + sPath : "") + (bSecure ? "; secure" : "");
  return true;
}

export function remove (sKey, sPath, sDomain) {
  if (!this.hasItem(sKey)) { return false; }
  document.cookie = encodeURIComponent(sKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT" 
    + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "");
  return true;
}

export function has (sKey) {
  if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) { return false; }
  return (new RegExp("(?:^|;\\s*)" 
    + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") 
    + "\\s*\\=")).test(document.cookie);
}

export function keys () { 
  var aKeys = document.cookie.replace(/((?:^|\s*;)[^\=]+)(?=;|$)|^\s*|\s*(?:\=[^;]*)?(?:\1|$)/g, "").split(/\s*(?:\=[^;]*)?;\s*/);
  for (var nLen = aKeys.length, nIdx = 0; nIdx < nLen; nIdx++) { aKeys[nIdx] = decodeURIComponent(aKeys[nIdx]); }
  return aKeys;
}
```

## Visuales

Para generar los visuales vamos a usar una de las librerías más populares para usar WebGL: ThreeJS. Como nuestra aplicación está hecha en React necesitamos también de una librería que conecte Three con React. Esa librería es [`react-three-fiber`](https://github.com/react-spring/react-three-fiber). Para este ejemplo vamos a usar también [`react-spring`](https://www.react-spring.io/) para facilitar las animaciones.

Como todas estas librerías se van a correr en el frontend, para instalarlas sólo necesitamos usar:

`
npm install three react-three-fiber react-spring
`

Ya teniendo todas las librerías hay que crear una escena que utilice la información de Spotify para ser audioreactiva. Aquí hay una escena muy sencilla que sirve para visualizar los diferentes tipos de ritmos que se obtienen de una canción. Sólo copia y pega este código en un archivo que se llame `Scene.js` en `src/components`.

```
Scene.js
import React from 'react';
import { Canvas, useThree, useFrame } from "react-three-fiber"
import { useSpring, a } from "react-spring/three"

function Tempo(props) {
  const { size, viewport } = useThree()
  const aspect = size.width / viewport.width
  const [spring, set] = useSpring(() => ({
    scale: [0.5, 0.5, 0.5],
    position: props.position,
    rotation: [0, 0, 0],
    config: { mass: 5, friction: 50, tension: 100 }
  }))

  useFrame(() => set({ scale: props.track.tempo_pulse ? [0.9, 0.9, 0.9] : [0.7, 0.7, 0.7] }));

  return (
    <a.mesh {...spring} castShadow>
      <dodecahedronBufferGeometry attach="geometry" args={[1.4, 0]} />
      <meshNormalMaterial attach="material" />
    </a.mesh>
  )
}

function Section(props) {

  const [spring, set] = useSpring(() => ({
    scale: [0.5, 0.5, 0.5],
    position: props.position,
    rotation: [0, 0, 0],
    config: { mass: 5, friction: 50, tension: 100 }
  }));

  useFrame(() => set({ scale: props.track.section_pulse ? [0.7, 0.7, 0.7] : [0.5, 0.5, 0.5] }));

  return (
    <a.mesh {...spring} castShadow>
      <dodecahedronBufferGeometry attach="geometry" args={[1.4, 0]} />
      <meshNormalMaterial attach="material" />
    </a.mesh>
  )
}


function Tatum(props) {

  const [spring, set] = useSpring(() => ({
    scale: [0.5, 0.5, 0.5],
    position: props.position,
    rotation: [0, 0, 0],
    config: { mass: 5, friction: 50, tension: 100 }
  }));

  useFrame(() => set({ scale: props.track.tatum_pulse ? [0.7, 0.7, 0.7] : [0.5, 0.5, 0.5] }));

  return (
    <a.mesh {...spring} castShadow>
      <dodecahedronBufferGeometry attach="geometry" args={[1.4, 0]} />
      <meshNormalMaterial attach="material" />
    </a.mesh>
  )
}

function Beat(props) {

  const [spring, set] = useSpring(() => ({
    scale: [0.5, 0.5, 0.5],
    position: props.position,
    rotation: [0, 0, 0],
    config: { mass: 5, friction: 50, tension: 100 }
  }));

  useFrame(() => set({ scale: props.track.beat_pulse ? [0.7, 0.7, 0.7] : [0.5, 0.5, 0.5] }));

  return (
    <a.mesh {...spring} castShadow>
      <dodecahedronBufferGeometry attach="geometry" args={[1.4, 0]} />
      <meshNormalMaterial attach="material" />
    </a.mesh>
  )
}


function Segment(props) {

  const [spring, set] = useSpring(() => ({
    scale: [0.5, 0.5, 0.5],
    position: props.position,
    rotation: [0, 0, 0],
    config: { mass: 5, friction: 50, tension: 100 }
  }));

  useFrame(() => set({ scale: props.track.segment_pulse ? [0.7, 0.7, 0.7] : [0.5, 0.5, 0.5] }));

  return (
    <a.mesh {...spring} castShadow>
      <dodecahedronBufferGeometry attach="geometry" args={[1.4, 0]} />
      <meshNormalMaterial attach="material" />
    </a.mesh>
  )
}

function Bar(props) {

  const [spring, set] = useSpring(() => ({
    scale: [0.5, 0.5, 0.5],
    position: props.position,
    rotation: [0, 0, 0],
    config: { mass: 5, friction: 50, tension: 100 }
  }));

  useFrame(() => set({ scale: props.track.bar_pulse ? [0.7, 0.7, 0.7] : [0.5, 0.5, 0.5] }));

  return (
    <a.mesh {...spring} castShadow>
      <dodecahedronBufferGeometry attach="geometry" args={[1.4, 0]} />
      <meshNormalMaterial attach="material" />
    </a.mesh>
  )
}

export default function DodecahedronScene(props) {

  const track = props.track;
  const active = props.active;


  return (
    <Canvas 
      style={{ background: "lightblue" }} 
      shadowMap 
      camera={{ position: [0, 0, 5] }}>

        <ambientLight intensity={0.5} />

        <spotLight
          intensity={0.6}
          position={[20, 10, 10]}
          angle={0.2}
          penumbra={1}
          shadow-mapSize-width={2048}
          shadow-mapSize-height={2048}
          castShadow />
          
        <mesh receiveShadow>
          <planeBufferGeometry attach="geometry" args={[1000, 1000]} />
          <meshPhongMaterial attach="material" color="#272727" />
        </mesh>

        <Tempo
          position={[0, 0, 0]}
          track={track} />

        <Section
          position={[2.5, 0, 0]}
          track={track} />

        <Tatum
          position={[-2.5, 0, 0]}
          track={track} />

        <Beat
          position={[0, 2.5, 0]}
          track={track} />

        <Segment
          position={[1.5, -2.5, 0]}
          track={track} />

        <Bar
          position={[-1.5, -2.5, 0]}
          track={track} />
    </Canvas>
  )
}
```

## Script principal

Ya tenemos el backend que nos da la información de la canción que escuchamos y el frontend que muestra esta información con visuales. Lo único que queda es unirlos.

El script principal va a manejar el _estado_ de la aplicación. En este caso sólo va a estar definido por dos valores: `active` y `track`. El primero define si hay alguna canción sonando en ese momento y el segundo tiene toda la información de la canción que esté sonando.

El componente que nos va a dar la información de Spotify (`APIHandler`) necesita de dos _callbacks_ dentro de sus _propiedades_, `setActive` y `setTrack` para poder cambiar el _estado_ del script principal.

El componente que crea los visuales (`DodecahedronScene`) necesita saber el _estado_ de la canción para mostrar lo que se está escuchando por lo que necesita tanto de `active` como de `track`.

Al final, el script `App.js` en la carpeta `src` debe de quedar así:

```
App.js
import React, { Component } from 'react';
import APIHandler from './components/APIHandler';
import Scene from './components/Scene';
import './App.css';

default class App extends Component{

  constructor(props){
    super(props);

    this.setActive = this.setActive.bind(this);
    this.setTrack = this.setTrack.bind(this);

    this.state = {
      active: false,
      track: {}
    };
  }

  setActive(active){
    this.setState({ active: active });
  }

  setTrack(track){
    this.setState({ track: track })
  }

  render() {

    const track = this.state.track;
    const active = this.state.active;

    return(
      <div className="main">

        <Scene
          active={active}
          track={track} />

        <ApiHandler
          active={active}
          setActive={this.setActive}
          setTrack={this.setTrack} />
      </div>
    );
  }
}
```

Por último, necesitamos hacer unos pequeños ajustes en el CSS para que la aplicación se vea bien. Para ello hay que cambiar `App.css` en la carpeta `src` a:

```
App.css
* {
  box-sizing: border-box;
}

html,
body,
#root {
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  overflow: hidden;
}

#root {
  overflow: auto;
}

body {
  position: fixed;
  overflow: hidden;
  overscroll-behavior-y: none;
  font-family: -apple-system, BlinkMacSystemFont, avenir next, avenir, helvetica neue, helvetica, ubuntu, roboto, noto, segoe ui, arial, sans-serif;
  color: white;
  -webkit-font-smoothing: antialiased;
}

.main {
  position: relative;
  width: 100%;
  height: 100%;
  color: #fff8de;
  overflow: hidden;
}

canvas {
  width: 100%;
  height: 100%;
  position: absolute;
  top: 0;
  overflow: hidden;
}
```

Si todo funciona como debería puedes correr `npm run start` en tu terminal, ir a `http://localhost:8000`, conectarte a tu cuenta de Spotify y ver a unos dodecahedros moverse.

## ...¿y ahora?

Este ejemplo es muy sencillo y sólo usa algunos de los parámetros que tiene Spotify en su análisis de las canciones. Además, `react-three-fiber` y ThreeJS te permiten hacer prácticamente lo que quieras en 3D. Lo único que queda es experimentar y ¡compartirlo!

Cualquier duda escribeme a mi [correo](mailto:dariozubi@gmail.com).